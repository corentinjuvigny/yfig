/*======================================================================
 *  Copyright 2017 Ivan Aug√©
 *
 *  This file is part of the YFIG software.
 * 
 *  YFIG is free  software;  you  can redistribute it and/or modify it
 *  under the terms of the GNU  General Public License as published by
 *  the  Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  YFIG software is distributed  in the  hope that it will be useful,
 *  but WITHOUT ANY WARRANTY;  without even the  implied  warranty  of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  the GNU
 *  General Public License for more details.
 * 
 *  You should have received  a copy of the GNU General Public License
 *  along with YFIG. If not, see <http://www.gnu.org/licenses/>.
**======================================================================
 *$Software: YFIG-MP (Mode Panel)
 *      $Id: symrot.c 353 2018-11-11 22:56:57Z ia $
 * $HeadURL: http://lunix120.ensiie.fr/yfig/trunk/yfig/common/modepanel/symrot.c $
 *  $Author: Ivan Auge (Email: auge@ensiie.fr)
**======================================================================*/

/*======================================================================*/
/*= mode panel: horizontal/vertical flip and rotation of objects.      =*/
/*======================================================================*/

#include "modepanel.h"
#include "yfig-efsmSelObj.h"

#include "fig/fig-scene.h"
#include "tools/geo2d.h"

#define MirrorHset "Set vert. mirror"
#define MirrorVset "Set horiz. mirror"
#define RotateCset "Set rot. center"

#define MirrorHunset "Unset mirror"
#define MirrorVunset "Unset mirror"
#define RotateCunset "Unset center"

#define RotCenter(ymw) ymw_drawopt_symrotCenter(ymw) ? "the object center" : "the selected point"  

/*======================================================================*/
/*= Interface                                                          =*/

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
// This function is performed when an object is selected.
static void mp_fliph_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos);
// This function is performed when the third button is clicked
static void mp_fliph_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos);

static Twid_mousefun3S mp_fliph_mess[] = {
    { "Flip object"  , "Copy & Flip"  , 0        }, // Begin
    { 0              , 0              , 0        }, // End
    { 0              , 0              , 0        }, // 
    { 0              , 0              , 0        },
};

extern void mp_fliph_cb(Tvgui_mw* vmw, int uid, void* ud)
{
    Tyfig_mw*        ymw  = (Tyfig_mw*)vmw;
    Tvgui_efsm**     ret  = (Tvgui_efsm**)ud;
    Twid_canvas*     cvs  = ymw->ymw_canvas;
    TefsmSel1Obj*    fsm;
    yfig_mw_usrmsg_printf(ymw,"flip object horizontally, "
                              "the symmetry axis is vertical and passes by %s.",RotCenter(ymw));

    fsm = yfig_efsmSel1Obj_new(cvs, FSC_MM_ALL, mp_fliph_objSel, ymw);
    fsm->fsm_posfunc = mp_fliph_btn2;
    yfig_dpp_showonly(ymw,DPP_SHOW_Zoom);
    vgui_efsm_mousefun_enable(&fsm->any, ymw->ymw_mouseFun, mp_fliph_mess);
    mp_fliph_mess[0].str[2] = MirrorHset;
    *ret = &fsm->any;
}

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
// This function is performed when an object is selected.
static void mp_flipv_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos);
// This function is performed when the third button is clicked
static void mp_flipv_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos);

#define mp_flipv_mess mp_fliph_mess

extern void mp_flipv_cb(Tvgui_mw* vmw, int uid, void* ud)
{
    Tyfig_mw*        ymw  = (Tyfig_mw*)vmw;
    Tvgui_efsm**     ret  = (Tvgui_efsm**)ud;
    Twid_canvas*     cvs  = ymw->ymw_canvas;
    TefsmSel1Obj*    fsm;
    yfig_mw_usrmsg_printf(ymw,"flip object vertically, "
                              "the symmetry axis is horizontal and passes by %s.",RotCenter(ymw));

    fsm = yfig_efsmSel1Obj_new(cvs, FSC_MM_ALL, mp_flipv_objSel, ymw);
    fsm->fsm_posfunc = mp_flipv_btn2;
    yfig_dpp_showonly(ymw,DPP_SHOW_Zoom);
    vgui_efsm_mousefun_enable(&fsm->any, ymw->ymw_mouseFun, mp_flipv_mess);
    mp_flipv_mess[0].str[2] = MirrorVset;
    *ret = &fsm->any;
}

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
// This function is performed when an object is selected.
static void mp_rotcw_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos);
// This function is performed when the third button is clicked
static void mp_rotcw_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos);

static Twid_mousefun3S mp_rotcw_mess[] = {
    { "Rotate object" , "Copy & Flip"  , 0        }, // Begin
    { 0               , 0              , 0        }, // End
    { 0               , 0              , 0        }, // 
    { 0               , 0              , 0        },
};

extern void mp_rotCW_cb(Tvgui_mw* vmw, int uid, void* ud)
{
    Tyfig_mw*        ymw  = (Tyfig_mw*)vmw;
    Tvgui_efsm**     ret  = (Tvgui_efsm**)ud;
    Twid_canvas*     cvs  = ymw->ymw_canvas;
    TefsmSel1Obj*    fsm;

    yfig_mw_usrmsg_printf(ymw,"rotate object clockwise by quarter turn, "
                              "the center being %s",RotCenter(ymw));

    fsm = yfig_efsmSel1Obj_new(cvs, FSC_MM_ALL, mp_rotcw_objSel, ymw);
    fsm->fsm_posfunc = mp_rotcw_btn2;
    yfig_dpp_showonly(ymw,DPP_SHOW_Zoom);
    vgui_efsm_mousefun_enable(&fsm->any, ymw->ymw_mouseFun, mp_rotcw_mess);
    mp_rotcw_mess[0].str[2] = RotateCset;
    *ret = &fsm->any;
}

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
// This function is performed when an object is selected.
static void mp_rotccw_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos);
// This function is performed when the third button is clicked
static void mp_rotccw_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos);

#define mp_rotccw_mess mp_rotcw_mess

extern void mp_rotCCW_cb(Tvgui_mw* vmw, int uid, void* ud)
{
    Tyfig_mw*        ymw  = (Tyfig_mw*)vmw;
    Tvgui_efsm**     ret  = (Tvgui_efsm**)ud;
    Twid_canvas*     cvs  = ymw->ymw_canvas;
    TefsmSel1Obj*    fsm;

    yfig_mw_usrmsg_printf(ymw,"rotate object counter-clockwise by quarter turn, "
                              "the center being %s",RotCenter(ymw));

    fsm = yfig_efsmSel1Obj_new(cvs, FSC_MM_ALL, mp_rotccw_objSel, ymw);
    fsm->fsm_posfunc = mp_rotccw_btn2;
    yfig_dpp_showonly(ymw,DPP_SHOW_Zoom);
    vgui_efsm_mousefun_enable(&fsm->any, ymw->ymw_mouseFun, mp_rotccw_mess);
    mp_rotccw_mess[0].str[2] = RotateCset;
    *ret = &fsm->any;
}

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
// This function is performed when an object is selected.
static void mp_rota_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos);
// This function is performed when the third button is clicked
static void mp_rota_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos);

#define mp_rota_mess mp_rotcw_mess

extern void mp_rota_cb(Tvgui_mw* vmw, int uid, void* ud)
{
    Tyfig_mw*        ymw  = (Tyfig_mw*)vmw;
    Tvgui_efsm**     ret  = (Tvgui_efsm**)ud;
    Twid_canvas*     cvs  = ymw->ymw_canvas;
    TefsmSel1Obj*    fsm;
    yfig_mw_usrmsg_printf(ymw,"rotate object, the center being %s",RotCenter(ymw));

    fsm = yfig_efsmSel1Obj_new(cvs, FSC_MM_ALL, mp_rota_objSel, ymw);
    fsm->fsm_posfunc = mp_rota_btn2;
    yfig_dpp_showonly(ymw,DPP_SHOW_Zoom|DPP_SHOW_Angle);
    vgui_efsm_mousefun_enable(&fsm->any, ymw->ymw_mouseFun, mp_rota_mess);
    mp_rota_mess[0].str[2] = RotateCset;
    *ret = &fsm->any;
}

/*======================================================================*/
/*= Private utilities                                                  =*/

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
static void mp_fliph_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)     fsm->fsm_userdata;
    Tyfig_device*  ydev = (Tyfig_device*) fsm->fsm_outdevice;
    Tdble2         axis;  // symmetry axe 
    
    if ( click!=1 && click!=2 ) return;

    // get symmetry axis
    if ( fsm->fsm_AxisVLine ) {
        axis = fsm->fsm_AxisPos;
    } else if ( ymw_drawopt_symrotCenter(ymw) ) {
        axis = obj_center( obj );
    } else {
        axis = pos;
    }

    // flip
    TobjAll clone = obj_newClone( obj );
    obj_flip(clone,1,0,0,axis.x,axis.y);
    if ( click==1 ) 
        yfig_cursce_chgObjWHis(ymw,obj,clone);
    else {
        yfig_cursce_addObjWHis(ymw,clone);
    }
    yfig_cursce_redraw(ymw);
}

static void mp_fliph_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)    fsm->fsm_userdata;
    Tyfig_device* fsod  = (Tyfig_device*)fsm->any.outdevice;
    if ( click!=3 ) return;

    if ( fsm->fsm_AxisVLine ) {
        fsm->fsm_AxisPos = dble2_init(0,0);
        fsm->fsm_AxisVLine = 0;
        mp_fliph_mess[0].str[2] = MirrorHset;
        yfig_mw_usrmsg_printf(ymw,"the symmetry axis is vertical and passes by %s.",RotCenter(ymw));
    } else {
        char tmp[100];
        fsm->fsm_AxisPos = pos;
        fsm->fsm_AxisVLine = 1;
        mp_fliph_mess[0].str[2] = MirrorHunset;
        yfig_mw_usrmsg_printf(ymw,"the symmetry axis is set to: x=%s",
            lu_LenPpiToUsrStr(&ymw->ymw_userUnit,pos.x,fsod_getPpiSrc(fsod),tmp));
    }
}

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
static void mp_flipv_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)     fsm->fsm_userdata;
    Tyfig_device*  ydev = (Tyfig_device*) fsm->fsm_outdevice;
    Tdble2         axis;  // symmetry axe or center
    
    if ( click!=1 && click!=2 ) return;

    // get symmetry axis
    if ( fsm->fsm_AxisHLine ) {
        axis = fsm->fsm_AxisPos;
    } else if ( ymw_drawopt_symrotCenter(ymw) ) {
        axis = obj_center( obj );
    } else {
        axis = pos;
    }

    // flip
    TobjAll clone = obj_newClone( obj );
    obj_flip(clone,0,1,0,axis.x,axis.y);
    if ( click==1 ) 
        yfig_cursce_chgObjWHis(ymw,obj,clone);
    else {
        yfig_cursce_addObjWHis(ymw,clone);
    }
    yfig_cursce_redraw(ymw);
}

static void mp_flipv_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)     fsm->fsm_userdata;
    Tyfig_device* fsod  = (Tyfig_device*)fsm->any.outdevice;
    if ( click!=3 ) return;

    if ( fsm->fsm_AxisHLine ) {
        fsm->fsm_AxisPos = dble2_init(0,0);
        fsm->fsm_AxisHLine = 0;
        mp_flipv_mess[0].str[2] = MirrorVset;
        yfig_mw_usrmsg_printf(ymw,"the symmetry axis is horizontal and passes by %s.",RotCenter(ymw));
    } else {
        char tmp[100];
        fsm->fsm_AxisPos = pos;
        fsm->fsm_AxisHLine = 1;
        mp_flipv_mess[0].str[2] = MirrorVunset;
        yfig_mw_usrmsg_printf(ymw,"the symmetry axis is set to: y=%s",
            lu_LenPpiToUsrStr(&ymw->ymw_userUnit,pos.y,fsod_getPpiSrc(fsod),tmp));
    }
}

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
static void mp_rot_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos, int r)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)     fsm->fsm_userdata;
    Tyfig_device*  ydev = (Tyfig_device*) fsm->fsm_outdevice;
    Tdble2         axis;  // rotation center
    
    if ( click!=1 && click!=2 ) return;

    // get rotation center axis
    if ( fsm->fsm_AxisDiag ) {
        axis = fsm->fsm_AxisPos;
    } else if ( ymw_drawopt_symrotCenter(ymw) ) {
        axis = obj_center( obj );
    } else {
        axis = pos;
    }

    // rotate
    TobjAll clone = obj_newClone( obj );
    obj_flip(clone,0,0,r,axis.x,axis.y);
    if ( click==1 ) 
        yfig_cursce_chgObjWHis(ymw,obj,clone);
    else {
        yfig_cursce_addObjWHis(ymw,clone);
    }
    yfig_cursce_redraw(ymw);
}

static void mp_rot_btn2(TefsmSel1Obj*fsm, int click, Tdble2 pos, Twid_mousefun3S*mess)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)     fsm->fsm_userdata;
    Tyfig_device* fsod  = (Tyfig_device*)fsm->any.outdevice;
    if ( click!=3 ) return;

    if ( fsm->fsm_AxisDiag ) {
        fsm->fsm_AxisPos = dble2_init(0,0);
        fsm->fsm_AxisDiag = 0;
        mess[0].str[2] = RotateCunset;
        yfig_mw_usrmsg_printf(ymw,"the rotation center is %s.",RotCenter(ymw));
    } else {
        char tmp[100],tmp2[100];
        fsm->fsm_AxisPos = pos;
        fsm->fsm_AxisDiag = 1;
        mess[0].str[2] = RotateCset;
        yfig_mw_usrmsg_printf(ymw,"the rotation center is (%s %s)",
            lu_LenPpiToUsrStr(&ymw->ymw_userUnit,pos.x,fsod_getPpiSrc(fsod),tmp),
            lu_LenPpiToUsrStr(&ymw->ymw_userUnit,pos.y,fsod_getPpiSrc(fsod),tmp));
    }
}

static void mp_rotcw_objSel (TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos) { mp_rot_objSel(fsm,click,obj,pos,1); }
static void mp_rotcw_btn2   (TefsmSel1Obj*fsm, int click, Tdble2 pos)              { mp_rot_btn2  (fsm,click,pos,mp_rotcw_mess); }
static void mp_rotccw_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos) { mp_rot_objSel(fsm,click,obj,pos,3); }
static void mp_rotccw_btn2  (TefsmSel1Obj*fsm, int click, Tdble2 pos)              { mp_rot_btn2  (fsm,click,pos,mp_rotccw_mess); }

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/
static void mp_rota_objSel(TefsmSel1Obj*fsm, int click, TobjAll obj, Tdble2 pos)
{
    Tyfig_mw*      ymw  = (Tyfig_mw*)     fsm->fsm_userdata;
    Tyfig_device*  ydev = (Tyfig_device*) fsm->fsm_outdevice;
    Tdble2         axis;  // rotation center
    
    if ( click!=1 && click!=2 ) return;

    // get rotation center axis
    if ( fsm->fsm_AxisDiag ) {
        axis = fsm->fsm_AxisPos;
    } else if ( ymw_drawopt_symrotCenter(ymw) ) {
        axis = obj_center( obj );
    } else {
        axis = pos;
    }

    // rotate
    double alpha = yfig_mw_getAngleRad(ymw);
    if ( dble_close0AtP(alpha,1e-1) ) {
        yfig_mw_errerr_printf(ymw,"rotation angle is 0");
        return;
    }
    TobjAll clone = obj_newClone( obj );
    obj_rotate(clone,-alpha,axis.x,axis.y);
    if ( click==1 ) 
        yfig_cursce_chgObjWHis(ymw,obj,clone);
    else {
        yfig_cursce_addObjWHis(ymw,clone);
    }
    yfig_cursce_redraw(ymw);
}

static void mp_rota_btn2  (TefsmSel1Obj*fsm, int click, Tdble2 pos) { mp_rot_btn2  (fsm,click,pos,mp_rota_mess); }

/*======================================================================*/
/*= Icons                                                              =*/

CUstr mp_fliph_big[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x02,0x00,0x00,0x00,0x1c,0xc0,0x01,0x00,0x00,0x22,
0x22,0x02,0x00,0x00,0x41,0x10,0x04,0x00,0x00,0x41,0x12,
0x04,0x00,0x00,0x41,0x10,0x04,0x00,0x00,0x22,0x22,0x02,
0x00,0x00,0x14,0x40,0x01,0x00,0x00,0x14,0x42,0x01,0x00,
0x80,0xe3,0x38,0x0e,0x00,0x40,0x00,0x07,0x10,0x00,0x20,
0xc3,0x18,0x24,0x00,0x90,0x22,0x27,0x4a,0x00,0x50,0x22,
0x22,0x52,0x00,0x30,0x41,0x10,0x64,0x00,0x00,0x41,0x12,
0x04,0x00,0x80,0x80,0x08,0x08,0x00,0x80,0x80,0x0a,0x08,
0x00,0x40,0x00,0x05,0x10,0x00,0xc0,0xeb,0xbf,0x1e,0x00,
0x00,0x2a,0xa0,0x02,0x00,0x00,0x2a,0xa2,0x02,0x00,0x00,
0x2a,0xa0,0x02,0x00,0x00,0x2a,0xa2,0x02,0x00,0x00,0x2a,
0xa0,0x02,0x00,0x00,0x2a,0xa2,0x02,0x00,0x00,0x3e,0xe0,
0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};
CUstr mp_fliph_small[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0xe4,0x00,
0x10,0x11,0x01,0x10,0x15,0x01,0x10,0x11,0x01,0xe0,0xe4,0x00,
0x40,0x40,0x00,0x48,0x44,0x02,0xb8,0xbb,0x03,0xa0,0xa4,0x00,
0x10,0x11,0x01,0x10,0x15,0x01,0xf8,0xfb,0x03,0xa0,0xa4,0x00,
0xa0,0xa0,0x00,0xa0,0xa4,0x00,0xb0,0xb1,0x01,0x00,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/

CUstr mp_flipv_big[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0xa0,0x00,
0x00,0x00,0x00,0xa0,0x00,0x04,0x00,0x00,0x10,0x01,0x02,
0x00,0x00,0x10,0x01,0x0f,0x00,0x00,0x08,0x02,0x32,0x00,
0x00,0x08,0x02,0x44,0x00,0x00,0x04,0x04,0x40,0x00,0x00,
0xfc,0x07,0x80,0x00,0x00,0x00,0x00,0x80,0x00,0x50,0x55,
0x55,0x81,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0xfc,0x07,
0x80,0x00,0x00,0x04,0x04,0x40,0x00,0x00,0x08,0x02,0x44,
0x00,0x00,0x08,0x02,0x32,0x00,0x00,0x10,0x01,0x0f,0x00,
0x00,0x10,0x01,0x02,0x00,0x00,0xa0,0x00,0x04,0x00,0x00,
0xa0,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x40,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};
CUstr mp_flipv_small[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x00,
0x00,0x0c,0x00,0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x21,0x00,
0x00,0x21,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0xf8,0xff,0x07,
0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0x21,0x00,0x00,0x21,0x00,
0x00,0x12,0x00,0x00,0x12,0x00,0x00,0x0c,0x00,0x00,0x0c,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/

CUstr mp_rotCCW_big[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x80,0x02,0x00,
0x00,0x00,0x40,0x1e,0x00,0x00,0x00,0x20,0x60,0x00,0x00,0x00,
0x20,0x80,0x00,0x00,0x00,0x40,0x1e,0x01,0x00,0x00,0x80,0x22,
0x01,0x00,0x00,0x00,0x43,0x02,0x00,0x00,0x00,0x42,0x02,0x00,
0x00,0x78,0x40,0x02,0x00,0x00,0x48,0x40,0x02,0x00,0x00,0x48,
0x40,0x02,0x00,0x00,0x90,0x20,0x01,0x00,0x00,0x10,0x1f,0x01,
0x00,0x00,0x20,0x80,0x00,0x00,0x00,0xc0,0x60,0x00,0x00,0x00,
0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x80,0x00,
0x02,0x00,0x88,0x80,0x00,0x02,0x00,0x88,0xcc,0x31,0xc7,0x00,
0x88,0x92,0x40,0x22,0x01,0x78,0x92,0x78,0xe2,0x01,0x88,0x92,
0x48,0x22,0x00,0x88,0x92,0x4a,0x2a,0x01,0x88,0x0c,0x71,0xc4,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,};
CUstr mp_rotCCW_small[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0xc0,0x00,0x00,
0xa0,0x3f,0x00,0x10,0x40,0x00,0x10,0x80,0x00,0xa0,0x1f,0x01,
0xc0,0x20,0x01,0x80,0x40,0x02,0x00,0x40,0x02,0x00,0x40,0x02,
0x00,0x40,0x02,0x60,0x40,0x02,0x90,0x20,0x01,0x10,0x1f,0x01,
0x20,0x80,0x00,0xc0,0x60,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/

CUstr mp_rotCW_big[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x28,0x00,
0x00,0x00,0x00,0x4f,0x00,0x00,0x00,0xc0,0x80,0x00,0x00,0x00,
0x20,0x80,0x00,0x00,0x00,0x10,0x4f,0x00,0x00,0x00,0x90,0x28,
0x00,0x00,0x00,0x48,0x18,0x00,0x00,0x00,0x48,0x08,0x00,0x00,
0x00,0x48,0xc0,0x03,0x00,0x00,0x48,0x40,0x02,0x00,0x00,0x48,
0x40,0x02,0x00,0x00,0x90,0x20,0x01,0x00,0x00,0x10,0x1f,0x01,
0x00,0x00,0x20,0x80,0x00,0x00,0x00,0xc0,0x60,0x00,0x00,0x00,
0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x80,0x00,
0x02,0x00,0x88,0x80,0x00,0x02,0x00,0x88,0xcc,0x31,0xc7,0x00,
0x88,0x92,0x40,0x22,0x01,0x78,0x92,0x78,0xe2,0x01,0x88,0x92,
0x48,0x22,0x00,0x88,0x92,0x4a,0x2a,0x01,0x88,0x0c,0x71,0xc4,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,};
CUstr mp_rotCW_small[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0xc0,0x00,
0x00,0x7f,0x01,0x80,0x00,0x02,0x40,0x00,0x02,0x20,0x7e,0x01,
0x20,0xc1,0x00,0x90,0x40,0x00,0x90,0x00,0x00,0x90,0x00,0x00,
0x90,0x00,0x00,0x90,0x80,0x01,0x20,0x41,0x02,0x20,0x3e,0x02,
0x40,0x00,0x01,0x80,0xc1,0x00,0x00,0x3e,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00};

/*=  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =*/

CUstr mp_rota_big[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x08, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00,
0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0xc0, 0x80, 0x00, 0x00, 0x00,
0x20, 0x80, 0x00, 0x00, 0x00, 0x10, 0x4f, 0x00, 0x00, 0x00, 0x90, 0x28,
0x00, 0x00, 0x00, 0x48, 0x18, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x48,
0x18, 0x00, 0x00, 0x00, 0x90, 0x28, 0x00, 0x00, 0x00, 0x10, 0x4f, 0x00,
0x00, 0x00, 0x20, 0x80, 0x00, 0x00, 0x00, 0xc0, 0x80, 0x00, 0x00, 0x00,
0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x18,
0x00, 0x00, 0x78, 0x80, 0x00, 0x02, 0x00, 0x88, 0x80, 0x00, 0x02, 0x00,
0x88, 0xcc, 0x31, 0xc7, 0x00, 0x88, 0x92, 0x40, 0x22, 0x01, 0x78, 0x92,
0x78, 0xe2, 0x01, 0x88, 0x92, 0x48, 0x22, 0x00, 0x88, 0x92, 0x4a, 0x2a,
0x01, 0x88, 0x0c, 0x71, 0xc4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00};
CUstr mp_rota_small[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xc0, 0x00,
0x00, 0x7f, 0x01, 0x80, 0x00, 0x02, 0x40, 0x00, 0x02, 0x20, 0x7e, 0x01,
0x20, 0xc1, 0x00, 0x90, 0x40, 0x00, 0x90, 0x00, 0x00, 0x90, 0x00, 0x00,
0x90, 0x00, 0x00, 0x90, 0x40, 0x00, 0x20, 0xc1, 0x00, 0x20, 0x7e, 0x01,
0x40, 0x00, 0x02, 0x80, 0x01, 0x02, 0x00, 0x7e, 0x01, 0x00, 0xc0, 0x00,
0x00, 0x40, 0x00, 0x00, 0x00, 0x00};

/*======================================================================*/
